<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Coq.Init.Datatypes</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Coq.Init.Datatypes</h1>

<div class="code">

<br/>

<br/>
<span class="id" type="keyword">Set Implicit Arguments</span>.<br/>

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="Coq.Init.Logic.html#"><span class="id" type="library">Logic</span></a>.<br/>
<span class="id" type="var">Declare</span> <span class="id" type="var">ML</span> <span class="id" type="keyword">Module</span> "nat_syntax_plugin".<br/>

<br/>
<span class="id" type="keyword">Global</span>&nbsp;<span class="id" type="keyword">Set</span> <span class="id" type="var">Universe</span> <span class="id" type="var">Polymorphism</span>.<br/>
<span class="id" type="keyword">Global</span>&nbsp;<span class="id" type="keyword">Set</span> <span class="id" type="var">Asymmetric</span> <span class="id" type="var">Patterns</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><a class="idref" href="Coq.Init.Datatypes.html#option"><span class="id" type="inductive">option</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> is the extension of <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> with an extra element <span class="inlinecode"><a class="idref" href="Coq.Init.Datatypes.html#None"><span class="id" type="constructor">None</span></a></span> 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="option"><span class="id" type="inductive">option</span></a> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="Some"><span class="id" type="constructor">Some</span></a> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Datatypes.html#option"><span class="id" type="inductive">option</span></a> <span class="id" type="var">A</span><br/>
&nbsp;&nbsp;| <a name="None"><span class="id" type="constructor">None</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#option"><span class="id" type="inductive">option</span></a> <span class="id" type="var">A</span>.<br/>

<br/>
<span class="id" type="var">Arguments</span> <a class="idref" href="Coq.Init.Datatypes.html#None"><span class="id" type="constructor">None</span></a> [<span class="id" type="var">A</span>].<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><a class="idref" href="Coq.Init.Datatypes.html#sum"><span class="id" type="inductive">sum</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.B"><span class="id" type="variable">B</span></a></span>, written <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.B"><span class="id" type="variable">B</span></a></span>, is the disjoint sum of <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> and <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.B"><span class="id" type="variable">B</span></a></span> 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="sum"><span class="id" type="inductive">sum</span></a> (<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>) : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="inl"><span class="id" type="constructor">inl</span></a> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Datatypes.html#sum"><span class="id" type="inductive">sum</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span><br/>
&nbsp;&nbsp;| <a name="inr"><span class="id" type="constructor">inr</span></a> : <span class="id" type="var">B</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Datatypes.html#sum"><span class="id" type="inductive">sum</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":type_scope:x_'+'_x"><span class="id" type="notation">"</span></a>x + y" := (<a class="idref" href="Coq.Init.Datatypes.html#sum"><span class="id" type="inductive">sum</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
<span class="id" type="var">Arguments</span> <a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" type="constructor">inl</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span>} <span class="id" type="var">_</span> , [<span class="id" type="var">A</span>] <span class="id" type="var">B</span> <span class="id" type="var">_</span>.<br/>
<span class="id" type="var">Arguments</span> <a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" type="constructor">inr</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span>} <span class="id" type="var">_</span> , <span class="id" type="var">A</span> [<span class="id" type="var">B</span>] <span class="id" type="var">_</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":type_scope:x_'\/'_x"><span class="id" type="notation">"</span></a>A \/ B" := (<span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">B</span>)%<span class="id" type="var">type</span> (<span class="id" type="var">only</span> <span class="id" type="var">parsing</span>) : <span class="id" type="var">type_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name="or"><span class="id" type="abbreviation">or</span></a> := <a class="idref" href="Coq.Init.Datatypes.html#sum"><span class="id" type="inductive">sum</span></a> (<span class="id" type="var">only</span> <span class="id" type="var">parsing</span>).<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><a class="idref" href="Coq.Init.Datatypes.html#prod"><span class="id" type="inductive">prod</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.B"><span class="id" type="variable">B</span></a></span>, written <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> <span class="inlinecode">×</span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.B"><span class="id" type="variable">B</span></a></span>, is the product of <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> and <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.B"><span class="id" type="variable">B</span></a></span>;
    the pair <span class="inlinecode"><a class="idref" href="Coq.Init.Datatypes.html#pair"><span class="id" type="constructor">pair</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.B"><span class="id" type="variable">B</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Fibrations.html#a"><span class="id" type="variable">a</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Fibrations.html#b"><span class="id" type="variable">b</span></a></span> of <span class="inlinecode"><a class="idref" href="HoTT.Fibrations.html#a"><span class="id" type="variable">a</span></a></span> and <span class="inlinecode"><a class="idref" href="HoTT.Fibrations.html#b"><span class="id" type="variable">b</span></a></span> is abbreviated <span class="inlinecode">(<a class="idref" href="HoTT.Fibrations.html#a"><span class="id" type="variable">a</span></a>,<a class="idref" href="HoTT.Fibrations.html#b"><span class="id" type="variable">b</span></a>)</span> 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="prod"><span class="id" type="inductive">prod</span></a> (<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>) : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<a name="pair"><span class="id" type="constructor">pair</span></a> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="var">B</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Datatypes.html#prod"><span class="id" type="inductive">prod</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span>.<br/>

<br/>
<span class="id" type="var">Arguments</span> <a class="idref" href="Coq.Init.Datatypes.html#pair"><span class="id" type="constructor">pair</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span>} <span class="id" type="var">_</span> <span class="id" type="var">_</span>.<br/>

<br/>
<span class="id" type="keyword">Add</span> <span class="id" type="keyword">Printing</span> <span class="id" type="keyword">Let</span> <span class="id" type="var">prod</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":type_scope:x_'*'_x"><span class="id" type="notation">"</span></a>x * y" := (<a class="idref" href="Coq.Init.Datatypes.html#prod"><span class="id" type="inductive">prod</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) : <span class="id" type="var">type_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name=":core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">"</span></a>( x , y , .. , z )" := (<a class="idref" href="Coq.Init.Datatypes.html#pair"><span class="id" type="constructor">pair</span></a> .. (<a class="idref" href="Coq.Init.Datatypes.html#pair"><span class="id" type="constructor">pair</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) .. <span class="id" type="var">z</span>) : <span class="id" type="var">core_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name=":type_scope:x_'/\'_x"><span class="id" type="notation">"</span></a>A /\ B" := (<a class="idref" href="Coq.Init.Datatypes.html#prod"><span class="id" type="inductive">prod</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span>) (<span class="id" type="var">only</span> <span class="id" type="var">parsing</span>) : <span class="id" type="var">type_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name="and"><span class="id" type="abbreviation">and</span></a> := <a class="idref" href="Coq.Init.Datatypes.html#prod"><span class="id" type="inductive">prod</span></a> (<span class="id" type="var">only</span> <span class="id" type="var">parsing</span>).<br/>
<span class="id" type="keyword">Notation</span> <a name="conj"><span class="id" type="abbreviation">conj</span></a> := <a class="idref" href="Coq.Init.Datatypes.html#pair"><span class="id" type="constructor">pair</span></a> (<span class="id" type="var">only</span> <span class="id" type="var">parsing</span>).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="fst"><span class="id" type="definition">fst</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">p</span> : <a class="idref" href="Coq.Init.Datatypes.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#B"><span class="id" type="variable">B</span></a>) := <span class="id" type="keyword">match</span> <a class="idref" href="Coq.Init.Datatypes.html#p"><span class="id" type="variable">p</span></a> <span class="id" type="keyword">with</span> <a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">x</span><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <span class="id" type="var">y</span><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> ⇒ <span class="id" type="var">x</span> <span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Definition</span> <a name="snd"><span class="id" type="definition">snd</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">p</span> : <a class="idref" href="Coq.Init.Datatypes.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#B"><span class="id" type="variable">B</span></a>) := <span class="id" type="keyword">match</span> <a class="idref" href="Coq.Init.Datatypes.html#p"><span class="id" type="variable">p</span></a> <span class="id" type="keyword">with</span> <a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">x</span><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <span class="id" type="var">y</span><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> ⇒ <span class="id" type="var">y</span> <span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Hint Resolve</span> <span class="id" type="var">pair</span> <span class="id" type="var">inl</span> <span class="id" type="var">inr</span> : <span class="id" type="var">core</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="prod_curry"><span class="id" type="definition">prod_curry</span></a> (<span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">C</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">f</span> : <a class="idref" href="Coq.Init.Datatypes.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Datatypes.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Datatypes.html#C"><span class="id" type="variable">C</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">p</span> : <a class="idref" href="Coq.Init.Datatypes.html#prod"><span class="id" type="inductive">prod</span></a> <a class="idref" href="Coq.Init.Datatypes.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Datatypes.html#B"><span class="id" type="variable">B</span></a>) : <a class="idref" href="Coq.Init.Datatypes.html#C"><span class="id" type="variable">C</span></a> := <span class="id" type="keyword">match</span> <a class="idref" href="Coq.Init.Datatypes.html#p"><span class="id" type="variable">p</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Coq.Init.Datatypes.html#pair"><span class="id" type="constructor">pair</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> ⇒ <a class="idref" href="Coq.Init.Datatypes.html#f"><span class="id" type="variable">f</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
&lt;-&gt; is wanted by ssreflect so we hack it here.  <span class="inlinecode"><a class="idref" href="Coq.Init.Datatypes.html#iff"><span class="id" type="inductive">iff</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.B"><span class="id" type="variable">B</span></a></span>, written <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> <span class="inlinecode">↔</span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.B"><span class="id" type="variable">B</span></a></span>, expresses the equivalence of <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> and <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.B"><span class="id" type="variable">B</span></a></span> 
</div>
<div class="code">

<br/>

<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <a name="iff"><span class="id" type="inductive">iff</span></a> (<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>) : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<a name="Iff"><span class="id" type="constructor">Iff</span></a>: <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="var">B</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">B</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="var">A</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Datatypes.html#iff"><span class="id" type="inductive">iff</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name=":type_scope:x_'<->'_x"><span class="id" type="notation">"</span></a>A &lt;-&gt; B" := (<a class="idref" href="Coq.Init.Datatypes.html#iff"><span class="id" type="inductive">iff</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span>) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">Empty_set</span></span> is a datatype with no inhabitant 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">unit</span></span> is a singleton datatype with sole inhabitant <span class="inlinecode"><a class="idref" href="HoTT.types.Unit.html#tt"><span class="id" type="constructor">tt</span></a></span> 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">bool</span></span> is the datatype of the boolean values <span class="inlinecode"><a class="idref" href="HoTT.types.Bool.html#true"><span class="id" type="constructor">true</span></a></span> and <span class="inlinecode"><a class="idref" href="HoTT.types.Bool.html#false"><span class="id" type="constructor">false</span></a></span> 
</div>
<div class="code">

<br/>

<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <a name="nat"><span class="id" type="inductive">nat</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="O"><span class="id" type="constructor">O</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a><br/>
&nbsp;&nbsp;| <a name="S"><span class="id" type="constructor">S</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>.<br/>

<br/>
<span class="id" type="keyword">Delimit</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">nat_scope</span> <span class="id" type="keyword">with</span> <span class="id" type="var">nat</span>.<br/>
<span class="id" type="keyword">Bind</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">nat_scope</span> <span class="id" type="keyword">with</span> <span class="id" type="var">nat</span>.<br/>
<span class="id" type="var">Arguments</span> <a class="idref" href="Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">_</span>%<span class="id" type="var">nat</span>.<br/>
<span class="id" type="var">Arguments</span> <a class="idref" href="Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">_</span>.<br/>

<br/>
<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">nat_scope</span>. 
<br/>
</div>

<div class="doc">
<span class="inlinecode"><a class="idref" href="Coq.Init.Datatypes.html#identity"><span class="id" type="inductive">identity</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Fibrations.html#a"><span class="id" type="variable">a</span></a></span> is the family of datatypes on <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> whose sole non-empty
    member is the singleton datatype <span class="inlinecode"><a class="idref" href="Coq.Init.Datatypes.html#identity"><span class="id" type="inductive">identity</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Fibrations.html#a"><span class="id" type="variable">a</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Fibrations.html#a"><span class="id" type="variable">a</span></a></span> whose
    sole inhabitant is denoted <span class="inlinecode"><span class="id" type="var">refl_identity</span></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Fibrations.html#a"><span class="id" type="variable">a</span></a></span> 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="identity"><span class="id" type="inductive">identity</span></a> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">a</span> : <a class="idref" href="Coq.Init.Datatypes.html#A"><span class="id" type="variable">A</span></a>) : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<a name="identity_refl"><span class="id" type="constructor">identity_refl</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#identity"><span class="id" type="inductive">identity</span></a> <span class="id" type="var">a</span> <span class="id" type="var">a</span>.<br/>

<br/>
<span class="id" type="keyword">Hint Resolve</span> <span class="id" type="var">identity_refl</span>: <span class="id" type="var">core</span>.<br/>

<br/>
<span class="id" type="var">Arguments</span> <a class="idref" href="Coq.Init.Datatypes.html#identity"><span class="id" type="inductive">identity</span></a> {<span class="id" type="var">A</span>} <span class="id" type="var">_</span> <span class="id" type="var">_</span>.<br/>
<span class="id" type="var">Arguments</span> <a class="idref" href="Coq.Init.Datatypes.html#identity_refl"><span class="id" type="constructor">identity_refl</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">a</span>} , [<span class="id" type="var">A</span>] <span class="id" type="var">a</span>.<br/>

<br/>
<span class="id" type="var">Arguments</span> <a class="idref" href="Coq.Init.Datatypes.html#identity_ind"><span class="id" type="definition">identity_ind</span></a> [<span class="id" type="var">A</span>] <span class="id" type="var">a</span> <span class="id" type="var">P</span> <span class="id" type="var">f</span> <span class="id" type="var">y</span> <span class="id" type="var">i</span>.<br/>
<span class="id" type="var">Arguments</span> <a class="idref" href="Coq.Init.Datatypes.html#identity_rec"><span class="id" type="definition">identity_rec</span></a> [<span class="id" type="var">A</span>] <span class="id" type="var">a</span> <span class="id" type="var">P</span> <span class="id" type="var">f</span> <span class="id" type="var">y</span> <span class="id" type="var">i</span>.<br/>
<span class="id" type="var">Arguments</span> <a class="idref" href="Coq.Init.Datatypes.html#identity_rect"><span class="id" type="definition">identity_rect</span></a> [<span class="id" type="var">A</span>] <span class="id" type="var">a</span> <span class="id" type="var">P</span> <span class="id" type="var">f</span> <span class="id" type="var">y</span> <span class="id" type="var">i</span>.<br/>

<br/>
</div>

<div class="doc">
Identity type 
</div>
<div class="code">

<br/>

<br/>
<span class="id" type="keyword">Delimit</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">identity_scope</span> <span class="id" type="keyword">with</span> <span class="id" type="var">identity</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":identity_scope:x_'='_x_':>'_x"><span class="id" type="notation">"</span></a>x = y :&gt; A" := (@<a class="idref" href="Coq.Init.Datatypes.html#identity"><span class="id" type="inductive">identity</span></a> <span class="id" type="var">A</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)%<span class="id" type="var">identity</span> : <span class="id" type="var">identity_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":identity_scope:x_'='_x"><span class="id" type="notation">"</span></a>x = y" := (<span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Datatypes.html#:identity_scope:x_'='_x_':>'_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">y</span> <a class="idref" href="Coq.Init.Datatypes.html#:identity_scope:x_'='_x_':>'_x"><span class="id" type="notation">:&gt;</span></a><span class="id" type="var">_</span>)%<span class="id" type="var">identity</span> : <span class="id" type="var">identity_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name=":identity_scope:x_'<>'_x_':>'_x"><span class="id" type="notation">"</span></a>x &lt;&gt; y  :&gt; T" := (<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a> <span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Datatypes.html#:identity_scope:x_'='_x_':>'_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">y</span> <a class="idref" href="Coq.Init.Datatypes.html#:identity_scope:x_'='_x_':>'_x"><span class="id" type="notation">:&gt;</span></a><span class="id" type="var">T</span>)%<span class="id" type="var">identity</span> : <span class="id" type="var">identity_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name=":identity_scope:x_'<>'_x"><span class="id" type="notation">"</span></a>x &lt;&gt; y" := (<span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Datatypes.html#:identity_scope:x_'<>'_x_':>'_x"><span class="id" type="notation">≠</span></a> <span class="id" type="var">y</span> <a class="idref" href="Coq.Init.Datatypes.html#:identity_scope:x_'<>'_x_':>'_x"><span class="id" type="notation">:&gt;</span></a><span class="id" type="var">_</span>)%<span class="id" type="var">identity</span> : <span class="id" type="var">identity_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Local</span>&nbsp;<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">identity_scope</span>.<br/>

<br/>
</div>

<div class="doc">
Another way of interpreting booleans as propositions 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Polymorphic lists and some operations 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="list"><span class="id" type="inductive">list</span></a> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;| <a name="nil"><span class="id" type="constructor">nil</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">A</span><br/>
&nbsp;| <a name="cons"><span class="id" type="constructor">cons</span></a> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">A</span>.<br/>

<br/>
<span class="id" type="var">Arguments</span> <a class="idref" href="Coq.Init.Datatypes.html#nil"><span class="id" type="constructor">nil</span></a> [<span class="id" type="var">A</span>].<br/>
<span class="id" type="keyword">Infix</span> <a name=":list_scope:x_'::'_x"><span class="id" type="notation">"</span></a>::" := <a class="idref" href="Coq.Init.Datatypes.html#cons"><span class="id" type="constructor">cons</span></a> (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 60, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>) : <span class="id" type="var">list_scope</span>.<br/>
<span class="id" type="keyword">Delimit</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">list_scope</span> <span class="id" type="keyword">with</span> <span class="id" type="var">list</span>.<br/>
<span class="id" type="keyword">Bind</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">list_scope</span> <span class="id" type="keyword">with</span> <span class="id" type="var">list</span>.<br/>

<br/>
<span class="id" type="keyword">Local</span>&nbsp;<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">list_scope</span>.<br/>
</div>

<div class="doc">
Concatenation of two lists 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="app"><span class="id" type="definition">app</span></a> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) : <a class="idref" href="Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Coq.Init.Datatypes.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Coq.Init.Datatypes.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Coq.Init.Datatypes.html#A"><span class="id" type="variable">A</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">fix</span> <span class="id" type="var">app</span> <span class="id" type="var">l</span> <span class="id" type="var">m</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Coq.Init.Datatypes.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <a class="idref" href="Coq.Init.Datatypes.html#nil"><span class="id" type="constructor">nil</span></a> ⇒ <a class="idref" href="Coq.Init.Datatypes.html#m"><span class="id" type="variable">m</span></a><br/>
&nbsp;&nbsp;&nbsp;| <span class="id" type="var">a</span> <a class="idref" href="Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">l1</span> ⇒ <span class="id" type="var">a</span> <a class="idref" href="Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="Coq.Init.Datatypes.html#app"><span class="id" type="variable">app</span></a> <span class="id" type="var">l1</span> <a class="idref" href="Coq.Init.Datatypes.html#m"><span class="id" type="variable">m</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Infix</span> <a name=":list_scope:x_'++'_x"><span class="id" type="notation">"</span></a>++" := <a class="idref" href="Coq.Init.Datatypes.html#app"><span class="id" type="definition">app</span></a> (<span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>, <span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 60) : <span class="id" type="var">list_scope</span>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>