<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>HoTT.types.Sigma</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library HoTT.types.Sigma</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab62"></a><h1 class="section">Theorems about Sigma-types (dependent sums)</h1>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="HoTT.Overture.html#"><span class="id" type="library">Overture</span></a> <a class="idref" href="HoTT.PathGroupoids.html#"><span class="id" type="library">PathGroupoids</span></a> <a class="idref" href="HoTT.Equivalences.html#"><span class="id" type="library">Equivalences</span></a> <a class="idref" href="HoTT.Contractible.html#"><span class="id" type="library">Contractible</span></a> <a class="idref" href="HoTT.Trunc.html#"><span class="id" type="library">Trunc</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="HoTT.types.Arrow.html#"><span class="id" type="library">Arrow</span></a>.<br/>
<span class="id" type="keyword">Local</span>&nbsp;<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">path_scope</span>.<br/>
<span class="id" type="keyword">Local</span>&nbsp;<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">equiv_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Generalizable</span> <span class="id" type="keyword">Variables</span> <span class="id" type="var">X</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">C</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span> <span class="id" type="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
In homotopy type theory, We think of elements of <span class="inlinecode"><span class="id" type="keyword">Type</span></span> as spaces, homotopy types, or weak omega-groupoids. A type family <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#Projections.P"><span class="id" type="variable">P</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="keyword">Type</span></span> corresponds to a fibration whose base is <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> and whose fiber over <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.x"><span class="id" type="variable">x</span></a></span> is <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#Projections.P"><span class="id" type="variable">P</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.x"><span class="id" type="variable">x</span></a></span>.

<div class="paragraph"> </div>

From such a <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#Projections.P"><span class="id" type="variable">P</span></a></span> we can build a total space over the base space <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> so that the fiber over <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.x"><span class="id" type="variable">x</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> is <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#Projections.P"><span class="id" type="variable">P</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.x"><span class="id" type="variable">x</span></a></span>. This is just Coq's dependent sum construction, written as <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#Projections.P"><span class="id" type="variable">P</span></a></span> or <span class="inlinecode">{<a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.x"><span class="id" type="variable">x</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> <span class="inlinecode">&amp;</span> <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#Projections.P"><span class="id" type="variable">P</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.x"><span class="id" type="variable">x</span></a>}</span>. The elements of <span class="inlinecode">{<a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.x"><span class="id" type="variable">x</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> <span class="inlinecode">&amp;</span> <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#Projections.P"><span class="id" type="variable">P</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.x"><span class="id" type="variable">x</span></a>}</span> are pairs, written <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#Projections.P"><span class="id" type="variable">P</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.x"><span class="id" type="variable">x</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.y"><span class="id" type="variable">y</span></a></span> in Coq, where <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.x"><span class="id" type="variable">x</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> and <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.y"><span class="id" type="variable">y</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#Projections.P"><span class="id" type="variable">P</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.x"><span class="id" type="variable">x</span></a></span>.  In <span class="inlinecode"><span class="id" type="var">Common.v</span></span> we defined the notation <span class="inlinecode">(<a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.x"><span class="id" type="variable">x</span></a>;<a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.y"><span class="id" type="variable">y</span></a>)</span> to mean <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a></span> <span class="inlinecode"><span class="id" type="var">_</span></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.x"><span class="id" type="variable">x</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.y"><span class="id" type="variable">y</span></a></span>.

<div class="paragraph"> </div>

The base and fiber components of a point in the total space are extracted with the two projections <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#projT1"><span class="id" type="definition">projT1</span></a></span> and <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#projT2"><span class="id" type="definition">projT2</span></a></span>. 
<div class="paragraph"> </div>

<a name="lab63"></a><h3 class="section">Unpacking</h3>

<div class="paragraph"> </div>

 Sometimes we would like to prove <span class="inlinecode"><a class="idref" href="HoTT.types.Sum.html#Q"><span class="id" type="variable">Q</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Fibrations.html#u"><span class="id" type="variable">u</span></a></span> where <span class="inlinecode"><a class="idref" href="HoTT.Fibrations.html#u"><span class="id" type="variable">u</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode">{<a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.x"><span class="id" type="variable">x</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.A"><span class="id" type="variable">A</span></a></span> <span class="inlinecode">&amp;</span> <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#Projections.P"><span class="id" type="variable">P</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Logic_Type.html#identity_is_a_congruence.x"><span class="id" type="variable">x</span></a>}</span> by writing <span class="inlinecode"><a class="idref" href="HoTT.Fibrations.html#u"><span class="id" type="variable">u</span></a></span> as a pair <span class="inlinecode">(<a class="idref" href="Coq.Init.Specif.html#projT1"><span class="id" type="definition">projT1</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Fibrations.html#u"><span class="id" type="variable">u</span></a></span> <span class="inlinecode">;</span> <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#projT2"><span class="id" type="definition">projT2</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Fibrations.html#u"><span class="id" type="variable">u</span></a>)</span>. This is accomplished by <span class="inlinecode"><span class="id" type="var">sigT_unpack</span></span>. We want tight control over the proof, so we just write it down even though is looks a bit scary. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="unpack_sigma"><span class="id" type="definition">unpack_sigma</span></a> `{<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} (<span class="id" type="var">Q</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>) (<span class="id" type="var">u</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>) :<br/>
&nbsp;&nbsp;<a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Coq.Init.Specif.html#projT1"><span class="id" type="definition">projT1</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="Coq.Init.Specif.html#projT2"><span class="id" type="definition">projT2</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><br/>
&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> <span class="id" type="var">H</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">let</span> (<span class="id" type="var">x</span>,<span class="id" type="var">p</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">u</span> <span class="id" type="keyword">return</span> (<a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Coq.Init.Specif.html#projT1"><span class="id" type="definition">projT1</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="Coq.Init.Specif.html#projT2"><span class="id" type="definition">projT2</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a>) := <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <span class="id" type="keyword">in</span> <a class="idref" href="HoTT.Overture.html#idmap"><span class="id" type="abbreviation">idmap</span></a>) <a class="idref" href="HoTT.types.Sigma.html#H"><span class="id" type="variable">H</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab64"></a><h3 class="section">Eta conversion</h3>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="eta_sigma"><span class="id" type="definition">eta_sigma</span></a> `{<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} (<span class="id" type="var">u</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Coq.Init.Specif.html#projT1"><span class="id" type="definition">projT1</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="Coq.Init.Specif.html#projT2"><span class="id" type="definition">projT2</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><br/>
&nbsp;&nbsp;:= <span class="id" type="keyword">match</span> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <span class="id" type="keyword">with</span> <a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> ⇒ 1 <span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="eta2_sigma"><span class="id" type="definition">eta2_sigma</span></a> `{<span class="id" type="var">P</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">a</span> : <span class="id" type="var">A</span>) (<span class="id" type="var">b</span> : <span class="id" type="var">B</span> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a>), <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">u</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">a</span> ⇒ <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> (<a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a>)))<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2.2</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">))</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><br/>
&nbsp;&nbsp;:= <span class="id" type="keyword">match</span> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <span class="id" type="keyword">with</span> <a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">x</span> (<a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">y</span> <span class="id" type="var">z</span>) ⇒ 1 <span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="eta3_sigma"><span class="id" type="definition">eta3_sigma</span></a> `{<span class="id" type="var">P</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">a</span> : <span class="id" type="var">A</span>) (<span class="id" type="var">b</span> : <span class="id" type="var">B</span> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a>) (<span class="id" type="var">c</span> : <span class="id" type="var">C</span> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.types.Sigma.html#b"><span class="id" type="variable">b</span></a>), <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">u</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">a</span> ⇒ <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">b</span> ⇒ <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> (<a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.types.Sigma.html#b"><span class="id" type="variable">b</span></a>))))<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2.2</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2.2.2</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)))</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><br/>
&nbsp;&nbsp;:= <span class="id" type="keyword">match</span> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <span class="id" type="keyword">with</span> <a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">x</span> (<a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">y</span> (<a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">z</span> <span class="id" type="var">w</span>)) ⇒ 1 <span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab65"></a><h3 class="section">Paths</h3>

<div class="paragraph"> </div>

 A path in a total space is commonly shown component wise. Because we use this over and over, we write down the proofs by hand to make sure they are what we think they should be. 
<div class="paragraph"> </div>

 With this version of the function, we often have to give <span class="inlinecode"><a class="idref" href="HoTT.Fibrations.html#u"><span class="id" type="variable">u</span></a></span> and <span class="inlinecode"><a class="idref" href="HoTT.Fibrations.html#v"><span class="id" type="variable">v</span></a></span> explicitly, so we make them explicit arguments. 
</div>
<div class="code">
<span class="id" type="keyword">Definition</span> <a name="path_sigma_uncurried"><span class="id" type="definition">path_sigma_uncurried</span></a> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">P</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>) (<span class="id" type="var">u</span> <span class="id" type="var">v</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">pq</span> : <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a><span class="id" type="var">p</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a>  <span class="id" type="var">p</span> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a><a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><br/>
&nbsp;&nbsp;:= <span class="id" type="keyword">match</span> <a class="idref" href="HoTT.types.Sigma.html#pq"><span class="id" type="variable">pq</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">p</span> <span class="id" type="var">q</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a>, <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a> <span class="id" type="keyword">return</span> (<span class="id" type="keyword">∀</span> <span class="id" type="var">p0</span>, <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#p0"><span class="id" type="variable">p0</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a><a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">)</span></a>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">x</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><span class="id" type="var">y</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>, <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">x'</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><span class="id" type="var">y'</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a> ⇒ <span class="id" type="keyword">fun</span> <span class="id" type="var">p1</span> <span class="id" type="var">q1</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="HoTT.types.Sigma.html#p1"><span class="id" type="variable">p1</span></a> <span class="id" type="keyword">in</span> (<span class="id" type="var">_</span> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">x''</span>) <span class="id" type="keyword">return</span> (<span class="id" type="keyword">∀</span> <span class="id" type="var">y''</span>, <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#p1"><span class="id" type="variable">p1</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <span class="id" type="var">y</span> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#y''"><span class="id" type="variable">y''</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">x</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><span class="id" type="var">y</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a><a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#x''"><span class="id" type="variable">x''</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><a class="idref" href="HoTT.types.Sigma.html#y''"><span class="id" type="variable">y''</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="HoTT.Overture.html#idpath"><span class="id" type="constructor">idpath</span></a> ⇒ <span class="id" type="keyword">fun</span> <span class="id" type="var">y'</span> <span class="id" type="var">q2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="HoTT.types.Sigma.html#q2"><span class="id" type="variable">q2</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="HoTT.Overture.html#idpath"><span class="id" type="constructor">idpath</span></a> ⇒ 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span> <span class="id" type="var">y'</span> <a class="idref" href="HoTT.types.Sigma.html#q1"><span class="id" type="variable">q1</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span> <span class="id" type="var">p</span> <span class="id" type="var">q</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
This is the curried one you usually want to use in practice.  We define it in terms of the uncurried one, since it's the uncurried one that is proven below to be an equivalence. 
</div>
<div class="code">
<span class="id" type="keyword">Definition</span> <a name="path_sigma"><span class="id" type="definition">path_sigma</span></a> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">P</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>) (<span class="id" type="var">u</span> <span class="id" type="var">v</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">p</span> : <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a>) (<span class="id" type="var">q</span> : <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><br/>
&nbsp;&nbsp;:= <a class="idref" href="HoTT.types.Sigma.html#path_sigma_uncurried"><span class="id" type="definition">path_sigma_uncurried</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>.<br/>

<br/>
</div>

<div class="doc">
A variant of <span class="inlinecode"><span class="id" type="var">Forall.dpath_forall</span></span> from which uses dependent sums to package things. It cannot go into <span class="inlinecode"><span class="id" type="library">Forall</span></span> because <span class="inlinecode"><span class="id" type="library">Sigma</span></span> depends on <span class="inlinecode"><span class="id" type="library">Forall</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="dpath_forall'"><span class="id" type="definition">dpath_forall'</span></a><br/>
&nbsp;&nbsp;{<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span> } (<span class="id" type="var">P</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>) (<span class="id" type="var">Q</span>: <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>) {<span class="id" type="var">x</span> <span class="id" type="var">y</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a>} (<span class="id" type="var">h</span> : <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#y"><span class="id" type="variable">y</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">f</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">p</span>, <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>) (<span class="id" type="var">g</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">p</span>, <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>)<br/>
&nbsp;:<br/>
&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">p</span>, <a class="idref" href="HoTT.Overture.html#transport"><span class="id" type="definition">transport</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> (<a class="idref" href="HoTT.types.Sigma.html#path_sigma"><span class="id" type="definition">path_sigma</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#y"><span class="id" type="variable">y</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <span class="id" type="var">_</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.types.Sigma.html#h"><span class="id" type="variable">h</span></a> 1) (<a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a>) <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#g"><span class="id" type="variable">g</span></a> (<a class="idref" href="HoTT.types.Sigma.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a>)<a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">p</span>, <a class="idref" href="HoTT.PathGroupoids.html#transportD"><span class="id" type="definition">transportD</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="keyword">fun</span> <span class="id" type="var">p</span> ⇒ <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>) <a class="idref" href="HoTT.types.Sigma.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> (<a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a>) <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#g"><span class="id" type="variable">g</span></a> (<a class="idref" href="HoTT.Overture.html#transport"><span class="id" type="definition">transport</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a>)<a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">h</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Equivalences.html#equiv_idmap"><span class="id" type="definition">equiv_idmap</span></a>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
This version produces only paths between pairs, as opposed to paths between arbitrary inhabitants of dependent sum types.  But it has the advantage that the components of those pairs can more often be inferred, so we make them implicit arguments. 
</div>
<div class="code">
<span class="id" type="keyword">Definition</span> <a name="path_sigma'"><span class="id" type="definition">path_sigma'</span></a> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">P</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>) {<span class="id" type="var">x</span> <span class="id" type="var">x'</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a>} {<span class="id" type="var">y</span> : <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a>} {<span class="id" type="var">y'</span> : <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#x'"><span class="id" type="variable">x'</span></a>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">p</span> : <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#x'"><span class="id" type="variable">x'</span></a>) (<span class="id" type="var">q</span> : <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#y'"><span class="id" type="variable">y'</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><a class="idref" href="HoTT.types.Sigma.html#y"><span class="id" type="variable">y</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#x'"><span class="id" type="variable">x'</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><a class="idref" href="HoTT.types.Sigma.html#y'"><span class="id" type="variable">y'</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;:= <a class="idref" href="HoTT.types.Sigma.html#path_sigma"><span class="id" type="definition">path_sigma</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><a class="idref" href="HoTT.types.Sigma.html#y"><span class="id" type="variable">y</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#x'"><span class="id" type="variable">x'</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><a class="idref" href="HoTT.types.Sigma.html#y'"><span class="id" type="variable">y'</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a>.<br/>

<br/>
</div>

<div class="doc">
Projections of paths from a total space. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="projT1_path"><span class="id" type="definition">projT1_path</span></a> `{<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} {<span class="id" type="var">u</span> <span class="id" type="var">v</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>} (<span class="id" type="var">p</span> : <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a><br/>
&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#ap"><span class="id" type="definition">ap</span></a> (@<a class="idref" href="Coq.Init.Specif.html#projT1"><span class="id" type="definition">projT1</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":fibration_scope:x_'..1'"><span class="id" type="notation">"</span></a>p ..1" := (<a class="idref" href="HoTT.types.Sigma.html#projT1_path"><span class="id" type="definition">projT1_path</span></a> <span class="id" type="var">p</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 3) : <span class="id" type="var">fibration_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="projT2_path"><span class="id" type="definition">projT2_path</span></a> `{<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} {<span class="id" type="var">u</span> <span class="id" type="var">v</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>} (<span class="id" type="var">p</span> : <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a>..<a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..1'"><span class="id" type="notation">1</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a><br/>
&nbsp;&nbsp;:= <a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.PathGroupoids.html#transport_compose"><span class="id" type="lemma">transport_compose</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> (@<a class="idref" href="Coq.Init.Specif.html#projT1"><span class="id" type="definition">projT1</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a><a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">)^</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">(</span></a>@<a class="idref" href="HoTT.Overture.html#apD"><span class="id" type="definition">apD</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a><span class="id" type="var">x</span><a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a><a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <span class="id" type="var">x</span><a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}</span></a> <span class="id" type="var">_</span> (@<a class="idref" href="Coq.Init.Specif.html#projT2"><span class="id" type="definition">projT2</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span> <span class="id" type="var">_</span> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a><a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":fibration_scope:x_'..2'"><span class="id" type="notation">"</span></a>p ..2" := (<a class="idref" href="HoTT.types.Sigma.html#projT2_path"><span class="id" type="definition">projT2_path</span></a> <span class="id" type="var">p</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 3) : <span class="id" type="var">fibration_scope</span>.<br/>

<br/>
</div>

<div class="doc">
Now we show how these things compute. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="projT1_path_sigma"><span class="id" type="definition">projT1_path_sigma</span></a> `{<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} {<span class="id" type="var">u</span> <span class="id" type="var">v</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">p</span> : <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a>) (<span class="id" type="var">q</span> : <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..1'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#path_sigma"><span class="id" type="definition">path_sigma</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a><a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..1'"><span class="id" type="notation">)</span></a>..<a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..1'"><span class="id" type="notation">1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">u</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">u1</span> <span class="id" type="var">u2</span>]; <span class="id" type="tactic">destruct</span> <span class="id" type="var">v</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">v1</span> <span class="id" type="var">v2</span>]; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> ×.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">p</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">q</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">q</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="projT2_path_sigma"><span class="id" type="definition">projT2_path_sigma</span></a> `{<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} {<span class="id" type="var">u</span> <span class="id" type="var">v</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">p</span> : <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a>) (<span class="id" type="var">q</span> : <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..2'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#path_sigma"><span class="id" type="definition">path_sigma</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a><a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..2'"><span class="id" type="notation">)</span></a>..<a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..2'"><span class="id" type="notation">2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Overture.html#ap"><span class="id" type="definition">ap</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">s</span> ⇒ <a class="idref" href="HoTT.Overture.html#transport"><span class="id" type="definition">transport</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#s"><span class="id" type="variable">s</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a>) (<a class="idref" href="HoTT.types.Sigma.html#projT1_path_sigma"><span class="id" type="definition">projT1_path_sigma</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a>) <a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">u</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">u1</span> <span class="id" type="var">u2</span>]; <span class="id" type="tactic">destruct</span> <span class="id" type="var">v</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">v1</span> <span class="id" type="var">v2</span>]; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> ×.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">p</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">q</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">q</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="eta_path_sigma"><span class="id" type="definition">eta_path_sigma</span></a> `{<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} {<span class="id" type="var">u</span> <span class="id" type="var">v</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>} (<span class="id" type="var">p</span> : <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.types.Sigma.html#path_sigma"><span class="id" type="definition">path_sigma</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a>..<a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..1'"><span class="id" type="notation">1</span></a>) (<a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a>..<a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..2'"><span class="id" type="notation">2</span></a>) <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">p</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">u</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
This lets us identify the path space of a sigma-type, up to equivalence. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Instance</span> <a name="isequiv_path_sigma"><span class="id" type="instance">isequiv_path_sigma</span></a> `{<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} {<span class="id" type="var">u</span> <span class="id" type="var">v</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>}<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Overture.html#IsEquiv"><span class="id" type="class">IsEquiv</span></a> (<a class="idref" href="HoTT.types.Sigma.html#path_sigma_uncurried"><span class="id" type="definition">path_sigma_uncurried</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a>) | 0.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.Equivalences.html#isequiv_adjointify"><span class="id" type="definition">isequiv_adjointify</span></a> <span class="id" type="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">r</span> ⇒ (<a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">p</span> : <span class="id" type="var">u</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">v</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> ⇒ <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <span class="id" type="var">u</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">v</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a>) <a class="idref" href="HoTT.types.Sigma.html#r"><span class="id" type="variable">r</span></a>..<a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..1'"><span class="id" type="notation">1</span></a> <a class="idref" href="HoTT.types.Sigma.html#r"><span class="id" type="variable">r</span></a>..<a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..2'"><span class="id" type="notation">2</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.types.Sigma.html#eta_path_sigma"><span class="id" type="definition">eta_path_sigma</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">u</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">u1</span> <span class="id" type="var">u2</span>]; <span class="id" type="tactic">destruct</span> <span class="id" type="var">v</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">v1</span> <span class="id" type="var">v2</span>]; <span class="id" type="tactic">intros</span> [<span class="id" type="var">p</span> <span class="id" type="var">q</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">p</span>, <span class="id" type="var">q</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">p</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">q</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">q</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="equiv_path_sigma"><span class="id" type="definition">equiv_path_sigma</span></a> `(<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>) (<span class="id" type="var">u</span> <span class="id" type="var">v</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a><span class="id" type="var">p</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a>  <span class="id" type="var">p</span> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a><a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;:= <a class="idref" href="HoTT.Overture.html#BuildEquiv"><span class="id" type="constructor">BuildEquiv</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<a class="idref" href="HoTT.types.Sigma.html#path_sigma_uncurried"><span class="id" type="definition">path_sigma_uncurried</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a>) <span class="id" type="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
This identification respects path concatenation. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="path_sigma_pp_pp"><span class="id" type="definition">path_sigma_pp_pp</span></a> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">P</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>) {<span class="id" type="var">u</span> <span class="id" type="var">v</span> <span class="id" type="var">w</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">p1</span> : <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a>) (<span class="id" type="var">q1</span> : <a class="idref" href="HoTT.types.Sigma.html#p1"><span class="id" type="variable">p1</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">p2</span> : <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#w"><span class="id" type="variable">w</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a>) (<span class="id" type="var">q2</span> : <a class="idref" href="HoTT.types.Sigma.html#p2"><span class="id" type="variable">p2</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#w"><span class="id" type="variable">w</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.types.Sigma.html#path_sigma"><span class="id" type="definition">path_sigma</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.types.Sigma.html#w"><span class="id" type="variable">w</span></a> (<a class="idref" href="HoTT.types.Sigma.html#p1"><span class="id" type="variable">p1</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.types.Sigma.html#p2"><span class="id" type="variable">p2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.PathGroupoids.html#transport_pp"><span class="id" type="definition">transport_pp</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#p1"><span class="id" type="variable">p1</span></a> <a class="idref" href="HoTT.types.Sigma.html#p2"><span class="id" type="variable">p2</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.Overture.html#ap"><span class="id" type="definition">ap</span></a> (<a class="idref" href="HoTT.Overture.html#transport"><span class="id" type="definition">transport</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#p2"><span class="id" type="variable">p2</span></a>) <a class="idref" href="HoTT.types.Sigma.html#q1"><span class="id" type="variable">q1</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.types.Sigma.html#q2"><span class="id" type="variable">q2</span></a>)<br/>
&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#path_sigma"><span class="id" type="definition">path_sigma</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a> <a class="idref" href="HoTT.types.Sigma.html#p1"><span class="id" type="variable">p1</span></a> <a class="idref" href="HoTT.types.Sigma.html#q1"><span class="id" type="variable">q1</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.types.Sigma.html#path_sigma"><span class="id" type="definition">path_sigma</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a> <a class="idref" href="HoTT.types.Sigma.html#w"><span class="id" type="variable">w</span></a> <a class="idref" href="HoTT.types.Sigma.html#p2"><span class="id" type="variable">p2</span></a> <a class="idref" href="HoTT.types.Sigma.html#q2"><span class="id" type="variable">q2</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">u</span>, <span class="id" type="var">v</span>, <span class="id" type="var">w</span>. <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> ×.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">p1</span>, <span class="id" type="var">p2</span>, <span class="id" type="var">q1</span>, <span class="id" type="var">q2</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="path_sigma_pp_pp'"><span class="id" type="definition">path_sigma_pp_pp'</span></a> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">P</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>)<br/>
&nbsp;&nbsp;{<span class="id" type="var">u1</span> <span class="id" type="var">v1</span> <span class="id" type="var">w1</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a>} {<span class="id" type="var">u2</span> : <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#u1"><span class="id" type="variable">u1</span></a>} {<span class="id" type="var">v2</span> : <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#v1"><span class="id" type="variable">v1</span></a>} {<span class="id" type="var">w2</span> : <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#w1"><span class="id" type="variable">w1</span></a>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">p1</span> : <a class="idref" href="HoTT.types.Sigma.html#u1"><span class="id" type="variable">u1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v1"><span class="id" type="variable">v1</span></a>) (<span class="id" type="var">q1</span> : <a class="idref" href="HoTT.types.Sigma.html#p1"><span class="id" type="variable">p1</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#u2"><span class="id" type="variable">u2</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v2"><span class="id" type="variable">v2</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">p2</span> : <a class="idref" href="HoTT.types.Sigma.html#v1"><span class="id" type="variable">v1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#w1"><span class="id" type="variable">w1</span></a>) (<span class="id" type="var">q2</span> : <a class="idref" href="HoTT.types.Sigma.html#p2"><span class="id" type="variable">p2</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#v2"><span class="id" type="variable">v2</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#w2"><span class="id" type="variable">w2</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.types.Sigma.html#path_sigma'"><span class="id" type="definition">path_sigma'</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="HoTT.types.Sigma.html#p1"><span class="id" type="variable">p1</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.types.Sigma.html#p2"><span class="id" type="variable">p2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.PathGroupoids.html#transport_pp"><span class="id" type="definition">transport_pp</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#p1"><span class="id" type="variable">p1</span></a> <a class="idref" href="HoTT.types.Sigma.html#p2"><span class="id" type="variable">p2</span></a> <a class="idref" href="HoTT.types.Sigma.html#u2"><span class="id" type="variable">u2</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.Overture.html#ap"><span class="id" type="definition">ap</span></a> (<a class="idref" href="HoTT.Overture.html#transport"><span class="id" type="definition">transport</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#p2"><span class="id" type="variable">p2</span></a>) <a class="idref" href="HoTT.types.Sigma.html#q1"><span class="id" type="variable">q1</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.types.Sigma.html#q2"><span class="id" type="variable">q2</span></a>)<br/>
&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#path_sigma'"><span class="id" type="definition">path_sigma'</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#p1"><span class="id" type="variable">p1</span></a> <a class="idref" href="HoTT.types.Sigma.html#q1"><span class="id" type="variable">q1</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.types.Sigma.html#path_sigma'"><span class="id" type="definition">path_sigma'</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#p2"><span class="id" type="variable">p2</span></a> <a class="idref" href="HoTT.types.Sigma.html#q2"><span class="id" type="variable">q2</span></a><br/>
&nbsp;&nbsp;:= @<a class="idref" href="HoTT.types.Sigma.html#path_sigma_pp_pp"><span class="id" type="definition">path_sigma_pp_pp</span></a> <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#u1"><span class="id" type="variable">u1</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><a class="idref" href="HoTT.types.Sigma.html#u2"><span class="id" type="variable">u2</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#v1"><span class="id" type="variable">v1</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><a class="idref" href="HoTT.types.Sigma.html#v2"><span class="id" type="variable">v2</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#w1"><span class="id" type="variable">w1</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><a class="idref" href="HoTT.types.Sigma.html#w2"><span class="id" type="variable">w2</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.types.Sigma.html#p1"><span class="id" type="variable">p1</span></a> <a class="idref" href="HoTT.types.Sigma.html#q1"><span class="id" type="variable">q1</span></a> <a class="idref" href="HoTT.types.Sigma.html#p2"><span class="id" type="variable">p2</span></a> <a class="idref" href="HoTT.types.Sigma.html#q2"><span class="id" type="variable">q2</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="path_sigma_p1_1p'"><span class="id" type="definition">path_sigma_p1_1p'</span></a> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">P</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>)<br/>
&nbsp;&nbsp;{<span class="id" type="var">u1</span> <span class="id" type="var">v1</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a>} {<span class="id" type="var">u2</span> : <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#u1"><span class="id" type="variable">u1</span></a>} {<span class="id" type="var">v2</span> : <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#v1"><span class="id" type="variable">v1</span></a>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">p</span> : <a class="idref" href="HoTT.types.Sigma.html#u1"><span class="id" type="variable">u1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v1"><span class="id" type="variable">v1</span></a>) (<span class="id" type="var">q</span> : <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#u2"><span class="id" type="variable">u2</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v2"><span class="id" type="variable">v2</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.types.Sigma.html#path_sigma'"><span class="id" type="definition">path_sigma'</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#path_sigma'"><span class="id" type="definition">path_sigma'</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> 1 <a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.types.Sigma.html#path_sigma'"><span class="id" type="definition">path_sigma'</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> 1 <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">p</span>, <span class="id" type="var">q</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><a class="idref" href="HoTT.types.Sigma.html#projT1_path"><span class="id" type="definition">projT1_path</span></a></span> also commutes with the groupoid structure. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="projT1_path_1"><span class="id" type="definition">projT1_path_1</span></a> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} {<span class="id" type="var">P</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} (<span class="id" type="var">u</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>)<br/>
: <a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..1'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.Overture.html#idpath"><span class="id" type="constructor">idpath</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..1'"><span class="id" type="notation">)</span></a> ..<a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..1'"><span class="id" type="notation">1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Overture.html#idpath"><span class="id" type="constructor">idpath</span></a> (<a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a>)<br/>
:= 1.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="projT1_path_pp"><span class="id" type="definition">projT1_path_pp</span></a> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} {<span class="id" type="var">P</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} {<span class="id" type="var">u</span> <span class="id" type="var">v</span> <span class="id" type="var">w</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">p</span> : <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a>) (<span class="id" type="var">q</span> : <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#w"><span class="id" type="variable">w</span></a>)<br/>
: <a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..1'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a><a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..1'"><span class="id" type="notation">)</span></a> ..<a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..1'"><span class="id" type="notation">1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> ..<a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..1'"><span class="id" type="notation">1</span></a><a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a> ..<a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..1'"><span class="id" type="notation">1</span></a><a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">)</span></a><br/>
:= <a class="idref" href="HoTT.PathGroupoids.html#ap_pp"><span class="id" type="definition">ap_pp</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="projT1_path_V"><span class="id" type="definition">projT1_path_V</span></a> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} {<span class="id" type="var">P</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} {<span class="id" type="var">u</span> <span class="id" type="var">v</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>} (<span class="id" type="var">p</span> : <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a>)<br/>
: <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a><a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">^</span></a> ..<a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..1'"><span class="id" type="notation">1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> ..<a class="idref" href="HoTT.types.Sigma.html#:fibration_scope:x_'..1'"><span class="id" type="notation">1</span></a><a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">)^</span></a><br/>
:= <a class="idref" href="HoTT.PathGroupoids.html#ap_V"><span class="id" type="definition">ap_V</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Applying <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a></span> to one argument is the same as <span class="inlinecode"><a class="idref" href="HoTT.types.Sigma.html#path_sigma"><span class="id" type="definition">path_sigma</span></a></span> with reflexivity in the first place. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="ap_existT"><span class="id" type="definition">ap_existT</span></a> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">P</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>) (<span class="id" type="var">x</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">y1</span> <span class="id" type="var">y2</span> : <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">q</span> : <a class="idref" href="HoTT.types.Sigma.html#y1"><span class="id" type="variable">y1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#y2"><span class="id" type="variable">y2</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Overture.html#ap"><span class="id" type="definition">ap</span></a> (<a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#path_sigma'"><span class="id" type="definition">path_sigma'</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> 1 <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">q</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Dependent transport is the same as transport along a <span class="inlinecode"><a class="idref" href="HoTT.types.Sigma.html#path_sigma"><span class="id" type="definition">path_sigma</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="transportD_is_transport"><span class="id" type="definition">transportD_is_transport</span></a><br/>
&nbsp;&nbsp;{<span class="id" type="var">A</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">B</span>:<a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a><span class="id" type="keyword">Type</span>) (<span class="id" type="var">C</span>:<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">x1</span> <span class="id" type="var">x2</span>:<a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">p</span>:<a class="idref" href="HoTT.types.Sigma.html#x1"><span class="id" type="variable">x1</span></a><a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a><a class="idref" href="HoTT.types.Sigma.html#x2"><span class="id" type="variable">x2</span></a>) (<span class="id" type="var">y</span>:<a class="idref" href="HoTT.types.Sigma.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="HoTT.types.Sigma.html#x1"><span class="id" type="variable">x1</span></a>) (<span class="id" type="var">z</span>:<a class="idref" href="HoTT.types.Sigma.html#C"><span class="id" type="variable">C</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#x1"><span class="id" type="variable">x1</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><a class="idref" href="HoTT.types.Sigma.html#y"><span class="id" type="variable">y</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.PathGroupoids.html#transportD"><span class="id" type="definition">transportD</span></a> <a class="idref" href="HoTT.types.Sigma.html#B"><span class="id" type="variable">B</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> ⇒ <a class="idref" href="HoTT.types.Sigma.html#C"><span class="id" type="variable">C</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><a class="idref" href="HoTT.types.Sigma.html#b"><span class="id" type="variable">b</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>) <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.types.Sigma.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="HoTT.types.Sigma.html#z"><span class="id" type="variable">z</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Overture.html#transport"><span class="id" type="definition">transport</span></a> <a class="idref" href="HoTT.types.Sigma.html#C"><span class="id" type="variable">C</span></a> (<a class="idref" href="HoTT.types.Sigma.html#path_sigma'"><span class="id" type="definition">path_sigma'</span></a> <a class="idref" href="HoTT.types.Sigma.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> 1) <a class="idref" href="HoTT.types.Sigma.html#z"><span class="id" type="variable">z</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">p</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Applying a function constructed with <span class="inlinecode"><a class="idref" href="Coq.Init.Specif.html#sigT_rect"><span class="id" type="definition">sigT_rect</span></a></span> to a <span class="inlinecode"><a class="idref" href="HoTT.types.Sigma.html#path_sigma"><span class="id" type="definition">path_sigma</span></a></span> can be computed.  Technically this computation should probably go by way of a 2-variable <span class="inlinecode"><a class="idref" href="HoTT.Overture.html#ap"><span class="id" type="definition">ap</span></a></span>, and should be done in the dependently typed case. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="ap_sigT_rectnd_path_sigma"><span class="id" type="definition">ap_sigT_rectnd_path_sigma</span></a> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">P</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>) {<span class="id" type="var">Q</span> : <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">x1</span> <span class="id" type="var">x2</span>:<a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">p</span>:<a class="idref" href="HoTT.types.Sigma.html#x1"><span class="id" type="variable">x1</span></a><a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a><a class="idref" href="HoTT.types.Sigma.html#x2"><span class="id" type="variable">x2</span></a>) (<span class="id" type="var">y1</span>:<a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#x1"><span class="id" type="variable">x1</span></a>) (<span class="id" type="var">y2</span>:<a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#x2"><span class="id" type="variable">x2</span></a>) (<span class="id" type="var">q</span>:<a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#y1"><span class="id" type="variable">y1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#y2"><span class="id" type="variable">y2</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">d</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span>, <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Overture.html#ap"><span class="id" type="definition">ap</span></a> (<a class="idref" href="Coq.Init.Specif.html#sigT_rect"><span class="id" type="definition">sigT_rect</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> ⇒ <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a>) <a class="idref" href="HoTT.types.Sigma.html#d"><span class="id" type="variable">d</span></a>) (<a class="idref" href="HoTT.types.Sigma.html#path_sigma'"><span class="id" type="definition">path_sigma'</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a>)<br/>
&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.PathGroupoids.html#transport_const"><span class="id" type="definition">transport_const</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <span class="id" type="var">_</span><a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">)^</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.Overture.html#ap"><span class="id" type="definition">ap</span></a> (<a class="idref" href="HoTT.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> ⇒ <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a>) <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a><a class="idref" href="HoTT.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#d"><span class="id" type="variable">d</span></a> <a class="idref" href="HoTT.types.Sigma.html#x1"><span class="id" type="variable">x1</span></a><a class="idref" href="HoTT.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">)</span></a>) (<a class="idref" href="HoTT.PathGroupoids.html#transport_Vp"><span class="id" type="definition">transport_Vp</span></a> <span class="id" type="var">_</span> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.types.Sigma.html#y1"><span class="id" type="variable">y1</span></a>)<a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">)^</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Arrow.html#transport_arrow"><span class="id" type="definition">transport_arrow</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span><a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">)^</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.Overture.html#ap10"><span class="id" type="definition">ap10</span></a> (<a class="idref" href="HoTT.Overture.html#apD"><span class="id" type="definition">apD</span></a> <a class="idref" href="HoTT.types.Sigma.html#d"><span class="id" type="variable">d</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a>) (<a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#y1"><span class="id" type="variable">y1</span></a>)<br/>
&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.Overture.html#ap"><span class="id" type="definition">ap</span></a> (<a class="idref" href="HoTT.types.Sigma.html#d"><span class="id" type="variable">d</span></a> <a class="idref" href="HoTT.types.Sigma.html#x2"><span class="id" type="variable">x2</span></a>) <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">p</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">q</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab66"></a><h3 class="section">Transport</h3>

<div class="paragraph"> </div>

 The concrete description of transport in sigmas (and also pis) is rather trickier than in the other types.  In particular, these cannot be described just in terms of transport in simpler types; they require also the dependent transport <span class="inlinecode"><a class="idref" href="HoTT.PathGroupoids.html#transportD"><span class="id" type="definition">transportD</span></a></span>.

<div class="paragraph"> </div>

  In particular, this indicates why "transport" alone cannot be fully defined by induction on the structure of types, although Id-elim/transportD can be (cf. Observational Type Theory).  A more thorough set of lemmas, along the lines of the present ones but dealing with Id-elim rather than just transport, might be nice to have eventually? 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="transport_sigma"><span class="id" type="definition">transport_sigma</span></a> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} {<span class="id" type="var">B</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} {<span class="id" type="var">C</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span>:<a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.types.Sigma.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;{<span class="id" type="var">x1</span> <span class="id" type="var">x2</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a>} (<span class="id" type="var">p</span> : <a class="idref" href="HoTT.types.Sigma.html#x1"><span class="id" type="variable">x1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#x2"><span class="id" type="variable">x2</span></a>) (<span class="id" type="var">yz</span> : <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">y</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.types.Sigma.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="HoTT.types.Sigma.html#x1"><span class="id" type="variable">x1</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="HoTT.types.Sigma.html#C"><span class="id" type="variable">C</span></a> <a class="idref" href="HoTT.types.Sigma.html#x1"><span class="id" type="variable">x1</span></a> <span class="id" type="var">y</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">y</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.types.Sigma.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="HoTT.types.Sigma.html#C"><span class="id" type="variable">C</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> <span class="id" type="var">y</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}</span></a>) <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.types.Sigma.html#yz"><span class="id" type="variable">yz</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#yz"><span class="id" type="variable">yz</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.PathGroupoids.html#transportD"><span class="id" type="definition">transportD</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.types.Sigma.html#yz"><span class="id" type="variable">yz</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.types.Sigma.html#yz"><span class="id" type="variable">yz</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">p</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">yz</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">y</span> <span class="id" type="var">z</span>]. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The special case when the second variable doesn't depend on the first is simpler. 
</div>
<div class="code">
<span class="id" type="keyword">Definition</span> <a name="transport_sigma'"><span class="id" type="definition">transport_sigma'</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>} {<span class="id" type="var">C</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.types.Sigma.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;{<span class="id" type="var">x1</span> <span class="id" type="var">x2</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a>} (<span class="id" type="var">p</span> : <a class="idref" href="HoTT.types.Sigma.html#x1"><span class="id" type="variable">x1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#x2"><span class="id" type="variable">x2</span></a>) (<span class="id" type="var">yz</span> : <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">y</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.types.Sigma.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="HoTT.types.Sigma.html#C"><span class="id" type="variable">C</span></a> <a class="idref" href="HoTT.types.Sigma.html#x1"><span class="id" type="variable">x1</span></a> <span class="id" type="var">y</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">y</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.types.Sigma.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="HoTT.types.Sigma.html#C"><span class="id" type="variable">C</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> <span class="id" type="var">y</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}</span></a>) <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.types.Sigma.html#yz"><span class="id" type="variable">yz</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#yz"><span class="id" type="variable">yz</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <a class="idref" href="HoTT.types.Sigma.html#C"><span class="id" type="variable">C</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.types.Sigma.html#yz"><span class="id" type="variable">yz</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a>) <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.types.Sigma.html#yz"><span class="id" type="variable">yz</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">p</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">yz</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab67"></a><h3 class="section">Functorial action</h3>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="functor_sigma"><span class="id" type="definition">functor_sigma</span></a> `{<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} `{<span class="id" type="var">Q</span> : <span class="id" type="var">B</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">f</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.types.Sigma.html#B"><span class="id" type="variable">B</span></a>) (<span class="id" type="var">g</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span>, <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> (<a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a>))<br/>
&nbsp;&nbsp;: <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a><br/>
&nbsp;&nbsp;:= <span class="id" type="keyword">fun</span> <span class="id" type="var">u</span> ⇒ <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.types.Sigma.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="ap_functor_sigma"><span class="id" type="definition">ap_functor_sigma</span></a> `{<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} `{<span class="id" type="var">Q</span> : <span class="id" type="var">B</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">f</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.types.Sigma.html#B"><span class="id" type="variable">B</span></a>) (<span class="id" type="var">g</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span>, <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> (<a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a>))<br/>
&nbsp;&nbsp;(<span class="id" type="var">u</span> <span class="id" type="var">v</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>) (<span class="id" type="var">p</span> : <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a>) (<span class="id" type="var">q</span> : <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Overture.html#ap"><span class="id" type="definition">ap</span></a> (<a class="idref" href="HoTT.types.Sigma.html#functor_sigma"><span class="id" type="definition">functor_sigma</span></a> <a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#g"><span class="id" type="variable">g</span></a>) (<a class="idref" href="HoTT.types.Sigma.html#path_sigma"><span class="id" type="definition">path_sigma</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a>)<br/>
&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Sigma.html#path_sigma"><span class="id" type="definition">path_sigma</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> (<a class="idref" href="HoTT.types.Sigma.html#functor_sigma"><span class="id" type="definition">functor_sigma</span></a> <a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a>) (<a class="idref" href="HoTT.types.Sigma.html#functor_sigma"><span class="id" type="definition">functor_sigma</span></a> <a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Overture.html#ap"><span class="id" type="definition">ap</span></a> <a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.PathGroupoids.html#transport_compose"><span class="id" type="lemma">transport_compose</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> (<a class="idref" href="HoTT.types.Sigma.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a>)<a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">)^</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">(</span></a>@<a class="idref" href="HoTT.PathGroupoids.html#ap_transport"><span class="id" type="lemma">ap_transport</span></a> <span class="id" type="var">_</span> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> (<a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a>)) <span class="id" type="var">_</span> <span class="id" type="var">_</span> <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.types.Sigma.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.types.Sigma.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a><a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">)^</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.Overture.html#ap"><span class="id" type="definition">ap</span></a> (<a class="idref" href="HoTT.types.Sigma.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.types.Sigma.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a>) <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">u</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">u1</span> <span class="id" type="var">u2</span>]; <span class="id" type="tactic">destruct</span> <span class="id" type="var">v</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">v1</span> <span class="id" type="var">v2</span>]; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">p</span>, <span class="id" type="var">q</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">p</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">q</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">q</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab68"></a><h3 class="section">Equivalences</h3>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Instance</span> <a name="isequiv_functor_sigma"><span class="id" type="instance">isequiv_functor_sigma</span></a> `{<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} `{<span class="id" type="var">Q</span> : <span class="id" type="var">B</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;`{<a class="idref" href="HoTT.Overture.html#IsEquiv"><span class="id" type="class">IsEquiv</span></a> <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="HoTT.types.Sigma.html#B"><span class="id" type="variable">B</span></a> <span class="id" type="var">f</span>} `{<span class="id" type="keyword">∀</span> <span class="id" type="var">a</span>, @<a class="idref" href="HoTT.Overture.html#IsEquiv"><span class="id" type="class">IsEquiv</span></a> (<a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a>) (<a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> (<a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a>)) (<span class="id" type="var">g</span> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a>)}<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Overture.html#IsEquiv"><span class="id" type="class">IsEquiv</span></a> (<a class="idref" href="HoTT.types.Sigma.html#functor_sigma"><span class="id" type="definition">functor_sigma</span></a> <a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#g"><span class="id" type="variable">g</span></a>) | 1000.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.Equivalences.html#isequiv_adjointify"><span class="id" type="definition">isequiv_adjointify</span></a> (<a class="idref" href="HoTT.types.Sigma.html#functor_sigma"><span class="id" type="definition">functor_sigma</span></a> <span class="id" type="var">f</span> <span class="id" type="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.types.Sigma.html#functor_sigma"><span class="id" type="definition">functor_sigma</span></a> (<span class="id" type="var">f</span><a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'^-1'"><span class="id" type="notation">^-1</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> ⇒ (<a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'^-1'"><span class="id" type="notation">(</span></a><span class="id" type="var">g</span> (<span class="id" type="var">f</span><a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'^-1'"><span class="id" type="notation">^-1</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a>)<a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'^-1'"><span class="id" type="notation">)^-1</span></a> (<a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.Overture.html#eisretr"><span class="id" type="method">eisretr</span></a> <span class="id" type="var">f</span> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">)^</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.types.Sigma.html#y"><span class="id" type="variable">y</span></a>)))) <span class="id" type="var">_</span> <span class="id" type="var">_</span>);<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> [<span class="id" type="var">x</span> <span class="id" type="var">y</span>].<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.types.Sigma.html#path_sigma'"><span class="id" type="definition">path_sigma'</span></a> <span class="id" type="var">_</span> (<a class="idref" href="HoTT.Overture.html#eisretr"><span class="id" type="method">eisretr</span></a> <span class="id" type="var">f</span> <span class="id" type="var">x</span>) <span class="id" type="var">_</span>); <span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> (<a class="idref" href="HoTT.Overture.html#eisretr"><span class="id" type="method">eisretr</span></a> (<span class="id" type="var">g</span> (<span class="id" type="var">f</span><a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'^-1'"><span class="id" type="notation">^-1</span></a> <span class="id" type="var">x</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.PathGroupoids.html#transport_pV"><span class="id" type="definition">transport_pV</span></a>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.types.Sigma.html#path_sigma'"><span class="id" type="definition">path_sigma'</span></a> <span class="id" type="var">_</span> (<a class="idref" href="HoTT.Overture.html#eissect"><span class="id" type="method">eissect</span></a> <span class="id" type="var">f</span> <span class="id" type="var">x</span>) <span class="id" type="var">_</span>); <span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.PathGroupoids.html#ap_transport"><span class="id" type="lemma">ap_transport</span></a> (<a class="idref" href="HoTT.Overture.html#eissect"><span class="id" type="method">eissect</span></a> <span class="id" type="var">f</span> <span class="id" type="var">x</span>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">x'</span> ⇒ <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'^-1'"><span class="id" type="notation">(</span></a><span class="id" type="var">g</span> <a class="idref" href="HoTT.types.Sigma.html#x'"><span class="id" type="variable">x'</span></a><a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'^-1'"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'^-1'"><span class="id" type="notation">^-1</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Overture.html#transport"><span class="id" type="definition">transport</span></a> <span class="id" type="var">Q</span> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.Overture.html#eisretr"><span class="id" type="method">eisretr</span></a> <span class="id" type="var">f</span> (<span class="id" type="var">f</span> <span class="id" type="var">x</span>)<a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">^</span></a> (<span class="id" type="var">g</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>))<a class="idref" href="HoTT.Overture.html#:path_scope:x_'^'"><span class="id" type="notation">)^</span></a> <a class="idref" href="HoTT.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <span class="id" type="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <a class="idref" href="HoTT.PathGroupoids.html#transport_compose"><span class="id" type="lemma">transport_compose</span></a>, <a class="idref" href="HoTT.Overture.html#eisadj"><span class="id" type="method">eisadj</span></a>, <a class="idref" href="HoTT.PathGroupoids.html#transport_pV"><span class="id" type="definition">transport_pV</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Overture.html#eissect"><span class="id" type="method">eissect</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="equiv_functor_sigma"><span class="id" type="definition">equiv_functor_sigma</span></a> `{<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} `{<span class="id" type="var">Q</span> : <span class="id" type="var">B</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">f</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.types.Sigma.html#B"><span class="id" type="variable">B</span></a>) `{<a class="idref" href="HoTT.Overture.html#IsEquiv"><span class="id" type="class">IsEquiv</span></a> <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="HoTT.types.Sigma.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">g</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span>, <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> (<a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a>))<br/>
&nbsp;&nbsp;`{<span class="id" type="keyword">∀</span> <span class="id" type="var">a</span>, @<a class="idref" href="HoTT.Overture.html#IsEquiv"><span class="id" type="class">IsEquiv</span></a> (<a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a>) (<a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> (<a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a>)) (<a class="idref" href="HoTT.types.Sigma.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a>)}<br/>
&nbsp;&nbsp;: <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a><br/>
&nbsp;&nbsp;:= <a class="idref" href="HoTT.Overture.html#BuildEquiv"><span class="id" type="constructor">BuildEquiv</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<a class="idref" href="HoTT.types.Sigma.html#functor_sigma"><span class="id" type="definition">functor_sigma</span></a> <a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#g"><span class="id" type="variable">g</span></a>) <span class="id" type="var">_</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="equiv_functor_sigma'"><span class="id" type="definition">equiv_functor_sigma'</span></a> `{<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} `{<span class="id" type="var">Q</span> : <span class="id" type="var">B</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">f</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.types.Sigma.html#B"><span class="id" type="variable">B</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">g</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span>, <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> (<a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a>))<br/>
&nbsp;&nbsp;: <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a><br/>
&nbsp;&nbsp;:= <a class="idref" href="HoTT.types.Sigma.html#equiv_functor_sigma"><span class="id" type="definition">equiv_functor_sigma</span></a> <a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#g"><span class="id" type="variable">g</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="equiv_functor_sigma_id"><span class="id" type="definition">equiv_functor_sigma_id</span></a> `{<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} `{<span class="id" type="var">Q</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">g</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span>, <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a><br/>
&nbsp;&nbsp;:= <a class="idref" href="HoTT.types.Sigma.html#equiv_functor_sigma"><span class="id" type="definition">equiv_functor_sigma</span></a> (<a class="idref" href="HoTT.Equivalences.html#equiv_idmap"><span class="id" type="definition">equiv_idmap</span></a> <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a>) <a class="idref" href="HoTT.types.Sigma.html#g"><span class="id" type="variable">g</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="equiv_sigma_contr"><span class="id" type="definition">equiv_sigma_contr</span></a> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">P</span> : <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>)<br/>
&nbsp;&nbsp;`{<span class="id" type="keyword">∀</span> <span class="id" type="var">a</span>, <a class="idref" href="HoTT.Overture.html#Contr"><span class="id" type="abbreviation">Contr</span></a> (<a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a>)}<br/>
&nbsp;&nbsp;: <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.Equivalences.html#equiv_adjointify"><span class="id" type="definition">equiv_adjointify</span></a> (@<a class="idref" href="Coq.Init.Specif.html#projT1"><span class="id" type="definition">projT1</span></a> <span class="id" type="var">A</span> <span class="id" type="var">P</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">a</span> ⇒ <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.Overture.html#center"><span class="id" type="method">center</span></a> (<span class="id" type="var">P</span> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a>)<a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>) <span class="id" type="var">_</span> <span class="id" type="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">a</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">p</span>]. <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.types.Sigma.html#path_sigma'"><span class="id" type="definition">path_sigma'</span></a> <span class="id" type="keyword">with</span> 1, <a class="idref" href="HoTT.Overture.html#contr"><span class="id" type="method">contr</span></a>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab69"></a><h3 class="section">Associativity</h3>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="equiv_sigma_assoc"><span class="id" type="definition">equiv_sigma_assoc</span></a> `(<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>) (<span class="id" type="var">Q</span> : <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a><span class="id" type="var">a</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <span class="id" type="var">a</span><a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>)<br/>
&nbsp;&nbsp;: <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a><span class="id" type="var">a</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a><span class="id" type="var">p</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <span class="id" type="var">a</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">a</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><span class="id" type="var">p</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a><a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (@<a class="idref" href="HoTT.Equivalences.html#equiv_adjointify"><span class="id" type="definition">equiv_adjointify</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a><span class="id" type="var">a</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a><span class="id" type="var">p</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <span class="id" type="var">P</span> <span class="id" type="var">a</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <span class="id" type="var">Q</span> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">a</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><span class="id" type="var">p</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a><a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}}</span></a> (<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <span class="id" type="var">Q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">apq</span> ⇒ <span class="id" type="keyword">let</span> (<span class="id" type="var">a</span>,<span class="id" type="var">pq</span>):=<a class="idref" href="HoTT.types.Sigma.html#apq"><span class="id" type="variable">apq</span></a> <span class="id" type="keyword">in</span> <span class="id" type="keyword">let</span> (<span class="id" type="var">p</span>,<span class="id" type="var">q</span>):=<a class="idref" href="HoTT.types.Sigma.html#pq"><span class="id" type="variable">pq</span></a> <span class="id" type="keyword">in</span> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">((</span></a><a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">);</span></a><a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">apq</span> ⇒ <span class="id" type="keyword">let</span> (<span class="id" type="var">ap</span>,<span class="id" type="var">q</span>):=<a class="idref" href="HoTT.types.Sigma.html#apq"><span class="id" type="variable">apq</span></a> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">let</span> (<span class="id" type="var">a</span>,<span class="id" type="var">p</span>) <span class="id" type="keyword">return</span> (<span class="id" type="var">Q</span> <a class="idref" href="HoTT.types.Sigma.html#ap"><span class="id" type="variable">ap</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a><span class="id" type="var">a</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a><span class="id" type="var">p</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <span class="id" type="var">P</span> <span class="id" type="var">a</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <span class="id" type="var">Q</span> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">a</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><span class="id" type="var">p</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a><a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}}</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= <a class="idref" href="HoTT.types.Sigma.html#ap"><span class="id" type="variable">ap</span></a> <span class="id" type="keyword">in</span> <span class="id" type="keyword">fun</span> <span class="id" type="var">q</span> ⇒ <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">p</span>:<span class="id" type="var">P</span> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a> ⇒ <span class="id" type="var">Q</span> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>) <a class="idref" href="HoTT.types.Sigma.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>) <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">_</span> <span class="id" type="var">_</span>).<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> [[<span class="id" type="var">a</span> <span class="id" type="var">p</span>] <span class="id" type="var">q</span>]; <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> [<span class="id" type="var">p</span> <span class="id" type="var">q</span>]]; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="equiv_sigma_prod"><span class="id" type="definition">equiv_sigma_prod</span></a> `(<span class="id" type="var">Q</span> : <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <span class="id" type="var">B</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>)<br/>
&nbsp;&nbsp;: <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a><span class="id" type="var">a</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a><span class="id" type="var">b</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.types.Sigma.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">a</span><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a><span class="id" type="var">b</span><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a><a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (@<a class="idref" href="HoTT.Equivalences.html#equiv_adjointify"><span class="id" type="definition">equiv_adjointify</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a><span class="id" type="var">a</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a><span class="id" type="var">b</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <span class="id" type="var">B</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <span class="id" type="var">Q</span> <a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">a</span><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a><span class="id" type="var">b</span><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a><a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}}</span></a> (<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <span class="id" type="var">Q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">abq</span> ⇒ <span class="id" type="keyword">let</span> (<span class="id" type="var">a</span>,<span class="id" type="var">bq</span>):=<a class="idref" href="HoTT.types.Sigma.html#abq"><span class="id" type="variable">abq</span></a> <span class="id" type="keyword">in</span> <span class="id" type="keyword">let</span> (<span class="id" type="var">b</span>,<span class="id" type="var">q</span>):=<a class="idref" href="HoTT.types.Sigma.html#bq"><span class="id" type="variable">bq</span></a> <span class="id" type="keyword">in</span> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a><a class="idref" href="HoTT.types.Sigma.html#b"><span class="id" type="variable">b</span></a><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">abq</span> ⇒ <span class="id" type="keyword">let</span> (<span class="id" type="var">ab</span>,<span class="id" type="var">q</span>):=<a class="idref" href="HoTT.types.Sigma.html#abq"><span class="id" type="variable">abq</span></a> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">let</span> (<span class="id" type="var">a</span>,<span class="id" type="var">b</span>) <span class="id" type="keyword">return</span> (<span class="id" type="var">Q</span> <a class="idref" href="HoTT.types.Sigma.html#ab"><span class="id" type="variable">ab</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a><span class="id" type="var">a</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a><span class="id" type="var">b</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <span class="id" type="var">B</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <span class="id" type="var">Q</span> <a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">a</span><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a><span class="id" type="var">b</span><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a><a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}}</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= <a class="idref" href="HoTT.types.Sigma.html#ab"><span class="id" type="variable">ab</span></a> <span class="id" type="keyword">in</span> <span class="id" type="keyword">fun</span> <span class="id" type="var">q</span> ⇒ <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">b</span>:<span class="id" type="var">B</span> ⇒ <span class="id" type="var">Q</span> <a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a><a class="idref" href="HoTT.types.Sigma.html#b"><span class="id" type="variable">b</span></a><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a>) <a class="idref" href="HoTT.types.Sigma.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>) <a class="idref" href="HoTT.types.Sigma.html#q"><span class="id" type="variable">q</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">_</span> <span class="id" type="var">_</span>).<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> [[<span class="id" type="var">a</span> <span class="id" type="var">b</span>] <span class="id" type="var">q</span>]; <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> [<span class="id" type="var">b</span> <span class="id" type="var">q</span>]]; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab70"></a><h3 class="section">Universal mapping properties</h3>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Instance</span> <a name="isequiv_sigT_rect"><span class="id" type="instance">isequiv_sigT_rect</span></a> `{<a class="idref" href="HoTT.Overture.html#Funext"><span class="id" type="class">Funext</span></a>} `{<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">Q</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Overture.html#IsEquiv"><span class="id" type="class">IsEquiv</span></a> (<a class="idref" href="Coq.Init.Specif.html#sigT_rect"><span class="id" type="definition">sigT_rect</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a>) | 0<br/>
&nbsp;&nbsp;:= <a class="idref" href="HoTT.Equivalences.html#isequiv_adjointify"><span class="id" type="definition">isequiv_adjointify</span></a> (<a class="idref" href="Coq.Init.Specif.html#sigT_rect"><span class="id" type="definition">sigT_rect</span></a> <span class="id" type="var">Q</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">f</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> ⇒ <a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><a class="idref" href="HoTT.types.Sigma.html#y"><span class="id" type="variable">y</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>)<br/>
&nbsp;&nbsp;<span class="id" type="var">_</span> <span class="id" type="var">_</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> <span class="id" type="var">f</span>; <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Overture.html#path_forall"><span class="id" type="definition">path_forall</span></a>; <span class="id" type="tactic">intros</span> [<span class="id" type="var">x</span> <span class="id" type="var">y</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> <span class="id" type="var">f</span>; <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Overture.html#path_forall"><span class="id" type="definition">path_forall</span></a>; <span class="id" type="tactic">intros</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Overture.html#path_forall"><span class="id" type="definition">path_forall</span></a>; <span class="id" type="tactic">intros</span> <span class="id" type="var">y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="equiv_sigT_rect"><span class="id" type="definition">equiv_sigT_rect</span></a> `{<a class="idref" href="HoTT.Overture.html#Funext"><span class="id" type="class">Funext</span></a>} `{<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">Q</span> : <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> (<span class="id" type="var">x</span>:<a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">y</span>:<a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a>), <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><a class="idref" href="HoTT.types.Sigma.html#y"><span class="id" type="variable">y</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a><a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">xy</span>, <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="HoTT.types.Sigma.html#xy"><span class="id" type="variable">xy</span></a><a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;:= <a class="idref" href="HoTT.Overture.html#BuildEquiv"><span class="id" type="constructor">BuildEquiv</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<a class="idref" href="Coq.Init.Specif.html#sigT_rect"><span class="id" type="definition">sigT_rect</span></a> <a class="idref" href="HoTT.types.Sigma.html#Q"><span class="id" type="variable">Q</span></a>) <span class="id" type="var">_</span>.<br/>

<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="sigT_corect_uncurried"><span class="id" type="definition">sigT_corect_uncurried</span></a><br/>
&nbsp;&nbsp;`{<span class="id" type="var">A</span> : <span class="id" type="var">X</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} (<span class="id" type="var">P</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>)<br/>
&nbsp;&nbsp;: <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">f</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> (<span class="id" type="var">f</span> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> (<a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a>)<a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;:= <span class="id" type="keyword">fun</span> <span class="id" type="var">fg</span> ⇒ <span class="id" type="keyword">let</span> (<span class="id" type="var">f</span>,<span class="id" type="var">g</span>) := <a class="idref" href="HoTT.types.Sigma.html#fg"><span class="id" type="variable">fg</span></a> <span class="id" type="keyword">in</span> <span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.types.Sigma.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="sigT_corect"><span class="id" type="definition">sigT_corect</span></a><br/>
&nbsp;&nbsp;`{<span class="id" type="var">A</span> : <span class="id" type="var">X</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} (<span class="id" type="var">P</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">f</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">g</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> (<a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a>))<br/>
&nbsp;&nbsp;: (<span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> (<a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a>))<br/>
&nbsp;&nbsp;:= <a class="idref" href="HoTT.types.Sigma.html#sigT_corect_uncurried"><span class="id" type="definition">sigT_corect_uncurried</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a><a class="idref" href="HoTT.types.Sigma.html#g"><span class="id" type="variable">g</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="id" type="keyword">Instance</span> <a name="isequiv_sigT_corect"><span class="id" type="instance">isequiv_sigT_corect</span></a> `{<a class="idref" href="HoTT.Overture.html#Funext"><span class="id" type="class">Funext</span></a>}<br/>
&nbsp;&nbsp;`{<span class="id" type="var">A</span> : <span class="id" type="var">X</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>} {<span class="id" type="var">P</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Overture.html#IsEquiv"><span class="id" type="class">IsEquiv</span></a> (<a class="idref" href="HoTT.types.Sigma.html#sigT_corect_uncurried"><span class="id" type="definition">sigT_corect_uncurried</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>) | 0<br/>
&nbsp;&nbsp;:= <a class="idref" href="HoTT.Equivalences.html#isequiv_adjointify"><span class="id" type="definition">isequiv_adjointify</span></a> (<a class="idref" href="HoTT.types.Sigma.html#sigT_corect_uncurried"><span class="id" type="definition">sigT_corect_uncurried</span></a> <span class="id" type="var">P</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">h</span> ⇒ <a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">f</span> ⇒ <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <span class="id" type="var">P</span> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> (<a class="idref" href="HoTT.types.Sigma.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">).1</span></a>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.types.Sigma.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">).2</span></a>))<br/>
&nbsp;&nbsp;<span class="id" type="var">_</span> <span class="id" type="var">_</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> <span class="id" type="var">h</span>; <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Overture.html#path_forall"><span class="id" type="definition">path_forall</span></a>; <span class="id" type="tactic">intros</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.types.Sigma.html#eta_sigma"><span class="id" type="definition">eta_sigma</span></a>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> [<span class="id" type="var">f</span> <span class="id" type="var">g</span>]; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="equiv_sigT_corect"><span class="id" type="definition">equiv_sigT_corect</span></a> `{<a class="idref" href="HoTT.Overture.html#Funext"><span class="id" type="class">Funext</span></a>}<br/>
&nbsp;&nbsp;`(<span class="id" type="var">A</span> : <span class="id" type="var">X</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>) (<span class="id" type="var">P</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>)<br/>
&nbsp;&nbsp;: <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">f</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a> (<span class="id" type="var">f</span> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> (<a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#x"><span class="id" type="variable">x</span></a>)<a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;:= <a class="idref" href="HoTT.Overture.html#BuildEquiv"><span class="id" type="constructor">BuildEquiv</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<a class="idref" href="HoTT.types.Sigma.html#sigT_corect_uncurried"><span class="id" type="definition">sigT_corect_uncurried</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>) <span class="id" type="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab71"></a><h3 class="section">Sigmas preserve truncation</h3>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Instance</span> <a name="trunc_sigma"><span class="id" type="instance">trunc_sigma</span></a> `{<span class="id" type="var">P</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;`{<a class="idref" href="HoTT.Overture.html#IsTrunc"><span class="id" type="class">IsTrunc</span></a> <span class="id" type="var">n</span> <a class="idref" href="HoTT.types.Sigma.html#A"><span class="id" type="variable">A</span></a>} `{<span class="id" type="keyword">∀</span> <span class="id" type="var">a</span>, <a class="idref" href="HoTT.Overture.html#IsTrunc"><span class="id" type="class">IsTrunc</span></a> <a class="idref" href="HoTT.types.Sigma.html#n"><span class="id" type="variable">n</span></a> (<a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.types.Sigma.html#a"><span class="id" type="variable">a</span></a>)}<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Overture.html#IsTrunc"><span class="id" type="class">IsTrunc</span></a> <a class="idref" href="HoTT.types.Sigma.html#n"><span class="id" type="variable">n</span></a> (<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="inductive">sigT</span></a> <a class="idref" href="HoTT.types.Sigma.html#P"><span class="id" type="variable">P</span></a>) | 100.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">generalize</span> <span class="id" type="tactic">dependent</span> <span class="id" type="var">A</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">n</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">P</span> <span class="id" type="var">ac</span> <span class="id" type="var">Pc</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">∃</span> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.Overture.html#center"><span class="id" type="method">center</span></a> <span class="id" type="var">A</span><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.Overture.html#center"><span class="id" type="method">center</span></a> (<span class="id" type="var">P</span> (<a class="idref" href="HoTT.Overture.html#center"><span class="id" type="method">center</span></a> <span class="id" type="var">A</span>))<a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> ?].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.types.Sigma.html#path_sigma'"><span class="id" type="definition">path_sigma'</span></a> <span class="id" type="var">P</span> (<a class="idref" href="HoTT.Overture.html#contr"><span class="id" type="method">contr</span></a> <span class="id" type="var">a</span>) (<a class="idref" href="HoTT.Contractible.html#path_contr"><span class="id" type="definition">path_contr</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span>)).<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> <span class="id" type="var">u</span> <span class="id" type="var">v</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.Trunc.html#trunc_equiv"><span class="id" type="definition">trunc_equiv</span></a> (<a class="idref" href="HoTT.types.Sigma.html#path_sigma_uncurried"><span class="id" type="definition">path_sigma_uncurried</span></a> <span class="id" type="var">P</span> <span class="id" type="var">u</span> <span class="id" type="var">v</span>)).<br/>
<span class="id" type="keyword">Defined</span>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>